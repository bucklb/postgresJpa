package com.example.postgresdemo.Validator;

import com.example.postgresdemo.exception.ApiError;
import com.example.postgresdemo.exception.ApiValidationException;
import com.example.postgresdemo.mapper.BirthMapper;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.assertj.core.api.AtomicReferenceArrayAssert;
import org.junit.Before;
import org.junit.Test;
import uk.gov.dwp.tuo.gen.domain.BirthCase;
import uk.gov.dwp.tuo.gen.domain.BirthCaseEnrichment;
import uk.gov.dwp.tuo.gen.domain.OrganisationsToInformResponse;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.SortedSet;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

public class ValidatorTests {


    static Validator validator;
    ObjectMapper mapper;
    ValidatorFactory factory;


    //
    // Would be nice to have a generic way to report the violations (as opposed to one per class)
    //
    public ApiValidationException parseViolations(Set<? extends ConstraintViolation<?>> violations) {
        System.out.println("== PARSING ==============================================");
        // Could look to build this in to ApiErrors??

        // In the absence of issues, probably safest to return null.  Caller may have checked first ...
        ApiValidationException avEx = null;

        if( violations.size() > 0 ) {

            // Something to report then
            ArrayList<ApiError> apiErrors = new ArrayList<>();
            for (ConstraintViolation c : violations) {

                // Build an error object per violation
                ApiError apiError = new ApiError();
                apiError.setField(c.getPropertyPath().toString() + " - " + c.getInvalidValue());
                apiError.setLocalizedErrorMessage(c.getMessage());

                // Add ro list of problems
                apiErrors.add( apiError );

            }

            // If we have something to say ...
            avEx = new ApiValidationException( apiErrors );

        }

        // Pass back what we may have
        return avEx;

    }




    @Before
    public void setup() {
        mapper = new ObjectMapper();
        // Play with validation type stuff
        factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    // Extend this to look at validating after deserializing
    private BirthCaseEnrichment deserialize(String bceStr){
        // Deserialise a nested object
        BirthCaseEnrichment bceObj=null;
        if (bceStr != null ) {
            try{
                bceObj = mapper.readValue(bceStr, BirthCaseEnrichment.class);
//                System.out.println(bceObj.toString());
            } catch (Exception ex) {
                System.out.println("DEserialisation not so good");
//                System.out.println(ex.getStackTrace());
            }
        }
        return bceObj;
    }

    private String serialize(BirthCaseEnrichment bceObj) {
        String bceStr="";
        // Serialise a nested object
        try {
            // The string generated by serialisation not terribly close to object's toString
            bceStr = mapper.writeValueAsString(bceObj);
//            System.out.println(bceStr);
        } catch (Exception ex) {
            System.out.println("Serialisation not so good");
//            System.out.println(ex.getStackTrace());
        }
        return bceStr;
    }

    // Generate some data to test mapping with ...
    private BirthCaseEnrichment birthCaseEnrichment(){
        BirthCaseEnrichment bce = new BirthCaseEnrichment();
        bce.setCouncil("county");
        bce.setOrganisationsToInform(new ArrayList<OrganisationsToInformResponse>());
        return bce;
    }

    // Make sure the (de)serialisation works ok
    @Test
    public void testToAndFrom(){
        BirthCaseEnrichment bce = birthCaseEnrichment();
        String bceStr=serialize(bce);
        assert(bce.equals(deserialize(serialize(bce))));
    }

    // Check that deserialising duff data will flag issues
    @Test
    public void testValidatorPostSerialisation() {
        BirthCaseEnrichment bce=birthCaseEnrichment();
        // Bugger up the enrichment
        bce.setCouncil(null);

        String bceStr = serialize(bce);
        BirthCaseEnrichment bceObj = deserialize(bceStr);

        BirthMapper bM = new BirthMapper();
        BirthCaseEnrichment b=bM.getValidatedFromString(bceStr);

        assertEquals(b,bce);


        Set<ConstraintViolation<BirthCaseEnrichment>> v = validator.validate(bceObj);
//        System.out.println(v.size());

        // Expect one problem
        assertEquals( 1, v.size() );

        // Expect that we can generate an exception
        ApiValidationException avEx = parseViolations( v );
        assertNotNull(avEx);

        List<ApiError> apiErrors = avEx.getApiErrors();
        assertEquals(1,apiErrors.size());

        assert(apiErrors.get(0).getField().contains("council"));
        assert(apiErrors.get(0).getLocalizedErrorMessage().contains("null"));


    }






    // This might be fun with the complex regex we use ??
    // Likely we will want to replicate (reuse?) the prettification we used for ApiError
    @Test
    public void testValidator(){

        BirthCase bc = new BirthCase();
        bc.setName("O");
        bc.setDateOfBirth("2010-10-20");

        Set<ConstraintViolation<BirthCase>> v = validator.validate(bc);

        parseViolations(v);

        // Could look to build this in to ApiErrors??
        for( ConstraintViolation c: v){
            String field= c.getPropertyPath().toString() + " - " + c.getInvalidValue();
            System.out.println(field);
            System.out.println(c.getMessage());
        }

        System.out.println(v.size());





    }




}
