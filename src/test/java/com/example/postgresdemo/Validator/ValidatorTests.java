package com.example.postgresdemo.Validator;

import com.example.postgresdemo.exception.ApiError;
import com.example.postgresdemo.exception.ApiValidationException;
import com.example.postgresdemo.mapper.BirthMapper;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.assertj.core.api.AtomicReferenceArrayAssert;
import org.junit.Before;
import org.junit.Test;
import uk.gov.dwp.tuo.gen.domain.BirthCase;
import uk.gov.dwp.tuo.gen.domain.BirthCaseEnrichment;
import uk.gov.dwp.tuo.gen.domain.OrganisationsToInformResponse;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import java.lang.reflect.Field;
import java.util.*;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

public class ValidatorTests {


    static Validator validator;
    ObjectMapper mapper;
    ValidatorFactory factory;


    //
    // Would be nice to have a generic way to report the violations (as opposed to one per class)
    //
    public ApiValidationException parseViolations(Set<? extends ConstraintViolation<?>> violations) {
        System.out.println("== PARSING ==============================================");
        // Could look to build this in to ApiErrors??

        // In the absence of issues, probably safest to return null.  Caller may have checked first ...
        ApiValidationException avEx = null;

        if( violations.size() > 0 ) {

            // Something to report then
            ArrayList<ApiError> apiErrors = new ArrayList<>();
            for (ConstraintViolation c : violations) {

                // Build an error object per violation
                ApiError apiError = new ApiError();
                apiError.setField(c.getPropertyPath().toString() + " - " + c.getInvalidValue());
                apiError.setLocalizedErrorMessage(c.getMessage());

                // Add ro list of problems
                apiErrors.add( apiError );

            }

            // If we have something to say ...
            avEx = new ApiValidationException( apiErrors );

        }

        // Pass back what we may have
        return avEx;

    }




    @Before
    public void setup() {
        mapper = new ObjectMapper();
        // Play with validation type stuff
        factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    // Extend this to look at validating after deserializing
    private BirthCaseEnrichment deserialize(String bceStr){
        // Deserialise a nested object
        BirthCaseEnrichment bceObj=null;
        if (bceStr != null ) {
            try{
                bceObj = mapper.readValue(bceStr, BirthCaseEnrichment.class);
//                System.out.println(bceObj.toString());
            } catch (Exception ex) {
                System.out.println("DEserialisation not so good");
//                System.out.println(ex.getStackTrace());
            }
        }
        return bceObj;
    }

    private String serialize(BirthCaseEnrichment bceObj) {
        String bceStr="";
        // Serialise a nested object
        try {
            // The string generated by serialisation not terribly close to object's toString
            bceStr = mapper.writeValueAsString(bceObj);
//            System.out.println(bceStr);
        } catch (Exception ex) {
            System.out.println("Serialisation not so good");
//            System.out.println(ex.getStackTrace());
        }
        return bceStr;
    }

    // Generate some data to test mapping with ...
    private BirthCaseEnrichment birthCaseEnrichment(){
        BirthCaseEnrichment bce = new BirthCaseEnrichment();
        bce.setCouncil("county");
//        bce.setOrganisationsToInform(new ArrayList<OrganisationsToInformResponse>());
        bce.setOrganisationsToInformResponse(new ArrayList<OrganisationsToInformResponse>());
        return bce;
    }

    // Make sure the (de)serialisation works ok
    @Test
    public void testToAndFrom(){
        BirthCaseEnrichment bce = birthCaseEnrichment();
        String bceStr=serialize(bce);
        assert(bce.equals(deserialize(serialize(bce))));
    }

    // Check that deserialising duff data will flag issues
    @Test
    public void testValidatorPostSerialisation() {
        BirthCaseEnrichment bce=birthCaseEnrichment();
        // Bugger up the enrichment
        bce.setCouncil(null);

        String bceStr = serialize(bce);
        BirthCaseEnrichment bceObj = deserialize(bceStr);

        BirthMapper bM = new BirthMapper();
        BirthCaseEnrichment b=bM.getValidatedFromString(bceStr);

        assertEquals(b,bce);


        Set<ConstraintViolation<BirthCaseEnrichment>> v = validator.validate(bceObj);
//        System.out.println(v.size());

        // Expect one problem
        assertEquals( 1, v.size() );

        // Expect that we can generate an exception
        ApiValidationException avEx = parseViolations( v );
        assertNotNull(avEx);

        List<ApiError> apiErrors = avEx.getApiErrors();
        assertEquals(1,apiErrors.size());

        assert(apiErrors.get(0).getField().contains("council"));
        assert(apiErrors.get(0).getLocalizedErrorMessage().contains("null"));


    }


    // This might be fun with the complex regex we use ??
    // Likely we will want to replicate (reuse?) the prettification we used for ApiError
    @Test
    public void testValidator(){

        BirthCase bc = new BirthCase();
        bc.setName("O");
        bc.setDateOfBirth("2010-10-20");

        Set<ConstraintViolation<BirthCase>> v = validator.validate(bc);

        parseViolations(v);

        // Could look to build this in to ApiErrors??
        for( ConstraintViolation c: v){
            String field= c.getPropertyPath().toString() + " : " + c.getInvalidValue();
            System.out.println(field);
            System.out.println(c.getMessage());
        }

        System.out.println(v.size());
    }



    @Test
    public void testBCEandEnum() throws Exception{

        BirthCaseEnrichment bce= birthCaseEnrichment();
        bce.setStatus(BirthCaseEnrichment.StatusEnum.BLACK);

        OrganisationsToInformResponse o = new OrganisationsToInformResponse();
//        o.setStatus(OrganisationsToInformResponse.StatusEnum.BLUE);
//        bce.getOrganisationsToInform().add(o);
        bce.getOrganisationsToInformResponse().add(o);


        String bceStr=serialize(bce);
//        bceStr=bceStr.replace("black","despair");



        BirthCaseEnrichment bc2 = deserialize(bceStr);

        Set<ConstraintViolation<BirthCaseEnrichment>> v = validator.validate(bc2);

        parseViolations(v);

        // Could look to build this in to ApiErrors??
        for( ConstraintViolation c: v){

            String field= c.getPropertyPath().toString() + " - " + c.getInvalidValue();
            System.out.println(field);
            System.out.println(c.getMessage());

            // base bit
            String clsName=c.getRootBeanClass().getName();
            String fldName=c.getPropertyPath().toString();
            System.out.println(clsName);

            // Try and deal with nesting.  Assumption of flat domain structure !! If none, then do nothing
            String[] fields=fldName.split("\\.");
            if(fields.length >1 ){

                // Lose the last part of the clsName (as we need to replace it with something based on penultimate bit of fields)
                String[] clsBits=clsName.split("\\.");
                clsName="";
                for(int i=0; i < clsBits.length -1 ; i++){
                    clsName=clsName+clsBits[i]+".";
                }
                System.out.println(clsName);

                // Want the root of penultimate field (lose any "")
                String[] fldBits=fields[fields.length-2].split("\\[");

                clsName = clsName + fldBits[0];
                fldName = fields[fields.length-1];
                System.out.println(clsName + "--" + fldName);

                OrganisationsToInformResponse xyz=new OrganisationsToInformResponse();
//                System.out.println(xyz.getClass().getName());
                clsName=xyz.getClass().getName();
                System.out.println(clsName + "--" + fldName);
            }


            // Link to stuff
            System.out.println("---->" + clsName + "<->" + fldName);
            System.out.println(c.getRootBeanClass().getName() + " >>> " + fldName);

            Class<?> C = Class.forName(clsName);
            Field f = C.getDeclaredField(fldName);
            if(f.getType().isEnum()) {
                System.out.println(Arrays.asList(f.getType().getEnumConstants()));
            }

        }





    }





}
