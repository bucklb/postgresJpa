package com.example.postgresdemo.mapper;

import com.example.postgresdemo.exception.ApiError;
import com.example.postgresdemo.exception.ApiValidationException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.Errors;
import uk.gov.dwp.tuo.gen.domain.BirthCaseEnrichment;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Set;


// Want something to deal with serialisation & deserialisation (and to ensure validation of the latter)
// means we can better trust what comes off the queue
public class BirthMapper {

    // TODO : Autowire?
    static Validator validator;
    ObjectMapper mapper;
    ValidatorFactory factory;


    @Autowired
    private Errors errors;


    // Take the given string, turn it in to a BirthCaseEnrichment, then check its validity
    public BirthCaseEnrichment getValidatedFromString( String serialisedBirthCaseEnrichment ) throws ApiValidationException {

        System.out.println(serialisedBirthCaseEnrichment);

        // Create an object
        BirthCaseEnrichment bceObj = deserialize( serialisedBirthCaseEnrichment );

        // Grab any validation issues
        Set<ConstraintViolation<BirthCaseEnrichment>> v = validator.validate(bceObj);


///        validator.validate(bceObj, errors)   ;


        // TODO : A decent place to add any business based errors (not really a date OR future dates)




        // If there were any validations passing them back by exception likely to be good
        if( v.size() > 0 ) {
            throw parseViolations(v);
        }

        // No good reason not to pass stuff back
        return bceObj;
    }



    // Extend this to look at validating after deserializing
    private BirthCaseEnrichment deserialize(String bceStr){
        // Deserialise a nested object
        mapper = new ObjectMapper();
        factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();

        BirthCaseEnrichment bceObj=null;
        if (bceStr != null ) {
            try{
                bceObj = mapper.readValue(bceStr, BirthCaseEnrichment.class);
//                System.out.println(bceObj.toString());
            } catch (Exception ex) {
                System.out.println("DEserialisation not so good");
//                System.out.println(ex.getStackTrace());
            }
        }
        return bceObj;
    }

    private String serialize(BirthCaseEnrichment bceObj) {
        mapper = new ObjectMapper();

        String bceStr="";
        // Serialise a nested object
        try {
            // The string generated by serialisation not terribly close to object's toString
            bceStr = mapper.writeValueAsString(bceObj);
//            System.out.println(bceStr);
        } catch (Exception ex) {
            System.out.println("Serialisation not so good");
//            System.out.println(ex.getStackTrace());
        }
        return bceStr;
    }

    //
    // Would be nice to have a generic way to report the violations (as opposed to one per class)
    //
    public ApiValidationException parseViolations(Set<? extends ConstraintViolation<?>> violations) {
        System.out.println("== PARSING ==============================================");
        // Could look to build this in to ApiErrors??

        // In the absence of issues, probably safest to return null.  Caller may have checked first ...
        ApiValidationException avEx = null;

        if( violations.size() > 0 ) {

            // Something to report then
            ArrayList<ApiError> apiErrors = new ArrayList<>();
            for (ConstraintViolation c : violations) {

                // Build an error object per violation
                ApiError apiError = new ApiError();
                apiError.setField(c.getPropertyPath().toString() + " - " + c.getInvalidValue());
                apiError.setLocalizedErrorMessage(c.getMessage());

                // Add ro list of problems
                apiErrors.add( apiError );

            }

            // Sorted list is probably easier for testing...
            Collections.sort(apiErrors, new Comparator<ApiError>() {
                public int compare(ApiError s1, ApiError s2) {
                    return s1.getField().compareToIgnoreCase(s2.getField());
                }
            });

            // If we have something to say ...
            avEx = new ApiValidationException( apiErrors );

        }

        // Pass back what we may have
        return avEx;

    }


}
